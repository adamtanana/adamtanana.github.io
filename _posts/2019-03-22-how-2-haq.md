---
layout: post
title: How to haq
author: adamt
---

Talk 1/n for UNSW SecSoc on basic into to binary exploitation

Prereqs to reading this
---------------------------

1. Assume you know how to write and compile C code
2. Assume you are somewhat familiar with `gcc` and the linux command line
3. Would help to have some knowledge of gdb & assembly but not required
4. This will cover linux 32bit stuff

How to haq
------------------

1. How does C work
2. How do computers work
3. How do I break computers

![noteasyfuckingrunagain](../static/beautiful.jpg)

Fast forward to part 3
--------------------------

A few questions before we start

1. What does the following code do
2. What's wrong with it?
3. How can we, without changing the source, call the function `notcalled()`?

```c
#include <stdio.h>

void notcalled() {
    printf("What\n");
}

void echo() {
    char buffer[16];

    printf("Enter some text\n");
    gets(buffer);
    printf("You entered %s\n", buffer);
}

int main() {
    echo();
    return 0;
}
```

Back to part 2: How do computer work?
---------------------------------

Let's start with some basics

* What is memory? (google this)
* What is a stack? 
* How does it work?
* What is assembly?

lets start by looking at the typical memory layout of a C program, in particular the stack, it's contents and job during fuction calls and returns. 

Photoshoot time...
## Memory layout of a running process

![Stack](http://i.stack.imgur.com/1Yz9K.gif)



### Stack

The stack is used by the program for 

* local variable storage (`buffer` in the code above)
* return addresses (will talk about later)
* Function paramaters

The stack is a LIFO structure, it grows downward in memory (from high addresses to lower addresses) as new functions are called. <br />
Every function gets its own section of the stack, to store its local variables

### Heap

The heap is ...

* All the dynamically allocated memory resides here
* Dynamically allocated memory => Whenever we use malloc to get memory dynamically

The heap grows upwards in memory(from lower to higher memory addresses) as more and more memory is required.

### Uninitialised Data (BSS)

* Any global variables in your program are stored here
* This consists of all global and static variables which are not initialized by the programmer. The kernel initializes them to 0 by default.

### Initialised data segment

* This is all global and static variables which is initialised to some default value by the developer

### Text

This is the fun section where all your executable code lives (as assembly)


## The CPU

![registers](http://flint.cs.yale.edu/cs421/papers/x86-asm/x86-registers.png)

### Instruction Pointer

The instruction pointer register stores the address of the next instruction to be executed by the CPU<br />
After every instruction, this is incremented

### Stack Pointer

The stack pointer stores the address of the top of the current stackframe (will describe below what a stackframe is)<br />
This is the address of the last element on the stack<br />
Since the stack grows down from high addresses to low addresses, `ESP` points to the value in the stackframe at the lowest memory address.

### Base Pointer

The base pointer is usually set to `ESP` at the start of a function.<br />
This is done to keep tab of function paramaters and local variables, as `ESP` is constantly changing, EBP will always point to the top of the stackframe. <br />

Local variables are stored below `EBP` and Function paramaters are stored above `EBP`

## Stackframe

![StackFrame](http://flint.cs.yale.edu/cs421/papers/x86-asm/stack-convention.png)



How do I break computers?
---------------------------------









